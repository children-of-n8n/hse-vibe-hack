name: Build and Deploy

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      build_backend:
        description: Build backend image
        required: false
        default: "true"
      build_frontend:
        description: Build frontend image
        required: false
        default: "true"
      build_bot:
        description: Build telegram bot image
        required: false
        default: "true"

permissions:
  contents: read
  pull-requests: read
  packages: write

jobs:
  detect-changes:
    name: Detect changes
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.filter.outputs.backend }}
      frontend: ${{ steps.filter.outputs.frontend }}
      telegram_bot: ${{ steps.filter.outputs.telegram_bot }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Filter paths
        id: filter
        uses: dorny/paths-filter@v3
        with:
          filters: |
            backend:
              - "apps/backend/**"
              - "bun.lock"
              - "package.json"
            frontend:
              - "apps/frontend/**"
              - "bun.lock"
              - "package.json"
            telegram_bot:
              - "apps/telegram-bot/**"
              - "bun.lock"
              - "package.json"

  backend-tests:
    name: Test backend
    needs: detect-changes
    if: (github.event_name == 'workflow_dispatch' && github.event.inputs.build_backend != 'false') || (github.event_name != 'workflow_dispatch' && needs.detect-changes.outputs.backend == 'true')
    runs-on: ubuntu-latest
    env:
      DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}
      JWT_SECRET: ${{ secrets.TEST_JWT_SECRET }}
      CORS_ORIGINS: ${{ secrets.TEST_CORS_ORIGINS }}
      AUTO_MIGRATE: ${{ secrets.TEST_AUTO_MIGRATE }}
      REDIS_URL: ${{ secrets.TEST_REDIS_URL }}
      S3_BUCKET: ${{ secrets.TEST_S3_BUCKET }}
      S3_REGION: ${{ secrets.TEST_S3_REGION }}
      S3_ACCESS_KEY: ${{ secrets.TEST_S3_ACCESS_KEY }}
      S3_SECRET_KEY: ${{ secrets.TEST_S3_SECRET_KEY }}
      S3_ENDPOINT: ${{ secrets.TEST_S3_ENDPOINT }}
      S3_PUBLIC_BASE_URL: ${{ secrets.TEST_S3_PUBLIC_BASE_URL }}
      APP_BASE_URL: ${{ secrets.TEST_APP_BASE_URL }}
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U postgres"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      minio:
        image: minio/minio:latest
        env:
          MINIO_ROOT_USER: minio
          MINIO_ROOT_PASSWORD: minio123
        ports:
          - 9000:9000
        entrypoint: ["/bin/sh", "-c", "minio server /data --console-address :9001"]
        options: >-
          --health-cmd "curl -f http://localhost:9000/minio/health/ready"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Prepare backend .env from example and secrets
        working-directory: apps/backend
        run: |
          cp .env.example .env
          if [ -n "${{ secrets.TEST_DATABASE_URL }}" ]; then
            echo "DATABASE_URL=${{ secrets.TEST_DATABASE_URL }}" >> .env
          fi
          if [ -n "${{ secrets.TEST_JWT_SECRET }}" ]; then
            echo "JWT_SECRET=${{ secrets.TEST_JWT_SECRET }}" >> .env
          fi
          if [ -n "${{ secrets.TEST_CORS_ORIGINS }}" ]; then
            echo "CORS_ORIGINS=${{ secrets.TEST_CORS_ORIGINS }}" >> .env
          fi
          if [ -n "${{ secrets.TEST_AUTO_MIGRATE }}" ]; then
            echo "AUTO_MIGRATE=${{ secrets.TEST_AUTO_MIGRATE }}" >> .env
          fi
          echo "REDIS_URL=${REDIS_URL:-redis://:redispass@redis:6379}" >> .env
          echo "S3_BUCKET=${S3_BUCKET:-test-bucket}" >> .env
          echo "S3_REGION=${S3_REGION:-us-east-1}" >> .env
          echo "S3_ACCESS_KEY=${S3_ACCESS_KEY:-minio}" >> .env
          echo "S3_SECRET_KEY=${S3_SECRET_KEY:-minio123}" >> .env
          echo "S3_ENDPOINT=${S3_ENDPOINT:-http://localhost:9000}" >> .env
          echo "S3_PUBLIC_BASE_URL=${S3_PUBLIC_BASE_URL:-http://localhost:9000}" >> .env
          echo "APP_BASE_URL=${APP_BASE_URL:-http://localhost:3000}" >> .env
      - name: Set up Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: 1.1.30
      - name: Install dependencies
        run: bun install --frozen-lockfile --ignore-scripts
      - name: Run backend tests
        working-directory: apps/backend
        run: bun test

  backend:
    name: Build backend image
    needs:
      - detect-changes
      - backend-tests
    if: github.event_name != 'pull_request' && ((github.event_name == 'workflow_dispatch' && github.event.inputs.build_backend != 'false') || (github.event_name != 'workflow_dispatch' && needs.detect-changes.outputs.backend == 'true'))
    runs-on: ubuntu-latest
    env:
      REGISTRY: ghcr.io
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set up Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: 1.1.30
      - name: Install dependencies
        run: bun install --frozen-lockfile --ignore-scripts
      - name: Ensure migrations are up-to-date
        working-directory: apps/backend
        run: |
          bun x drizzle-kit generate --config ./drizzle.config.ts
          git diff --quiet --exit-code ./src/db/migrations || (echo "Migrations not committed. Run the generate command locally and commit the changes." && exit 1)
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Set image namespace
        run: |
          owner="${{ github.repository_owner }}"
          owner_lower=$(echo "$owner" | tr '[:upper:]' '[:lower:]')
          echo "IMAGE_NAMESPACE=$owner_lower" >> "$GITHUB_ENV"
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Build and push backend
        uses: docker/build-push-action@v6
        with:
          context: .
          file: apps/backend/Dockerfile
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/hse-vibe-hack-backend:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/hse-vibe-hack-backend:${{ github.sha }}
#          cache-from: type=gha,scope=backend
#          cache-to: type=gha,mode=max,scope=backend

  frontend:
    name: Build frontend image
    needs: detect-changes
    if: github.event_name != 'pull_request' && ((github.event_name == 'workflow_dispatch' && github.event.inputs.build_frontend != 'false') || (github.event_name != 'workflow_dispatch' && needs.detect-changes.outputs.frontend == 'true'))
    runs-on: ubuntu-latest
    env:
      REGISTRY: ghcr.io
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Set image namespace
        run: |
          owner="${{ github.repository_owner }}"
          owner_lower=$(echo "$owner" | tr '[:upper:]' '[:lower:]')
          echo "IMAGE_NAMESPACE=$owner_lower" >> "$GITHUB_ENV"
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Build and push frontend
        uses: docker/build-push-action@v6
        with:
          context: .
          file: apps/frontend/Dockerfile
          build-args: |
            API_BASE_URL=https://backend.hsevibehack.hacks.intezya.ru
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/hse-vibe-hack-frontend:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/hse-vibe-hack-frontend:${{ github.sha }}
#          cache-from: type=gha,scope=frontend
#          cache-to: type=gha,mode=max,scope=frontend

  telegram-bot:
    name: Build telegram bot image
    needs: detect-changes
    if: github.event_name != 'pull_request' && ((github.event_name == 'workflow_dispatch' && github.event.inputs.build_bot != 'false') || (github.event_name != 'workflow_dispatch' && needs.detect-changes.outputs.telegram_bot == 'true'))
    runs-on: ubuntu-latest
    env:
      REGISTRY: ghcr.io
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Set image namespace
        run: |
          owner="${{ github.repository_owner }}"
          owner_lower=$(echo "$owner" | tr '[:upper:]' '[:lower:]')
          echo "IMAGE_NAMESPACE=$owner_lower" >> "$GITHUB_ENV"
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Build and push telegram bot
        uses: docker/build-push-action@v6
        with:
          context: .
          file: apps/telegram-bot/Dockerfile
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/hse-vibe-hack-telegram-bot:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/hse-vibe-hack-telegram-bot:${{ github.sha }}
#          cache-from: type=gha,scope=telegram-bot
#          cache-to: type=gha,mode=max,scope=telegram-bot

  deploy-backend:
    name: Deploy backend to Dokploy
    needs: backend
    if: needs.backend.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to Dokploy (backend)
        env:
          BACKEND_DEPLOY_URL: ${{ secrets.DOKPLOY_BACKEND_DEPLOY_URL }}
        run: |
          if [ -z "${BACKEND_DEPLOY_URL}" ]; then
            echo "Missing BACKEND_DEPLOY_URL secret" >&2
            exit 1
          fi

          curl -X GET "${BACKEND_DEPLOY_URL}"

  deploy-frontend:
    name: Deploy frontend to Dokploy
    needs: frontend
    if: needs.frontend.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to Dokploy (frontend)
        env:
          DOKPLOY_API_KEY: ${{ secrets.DOKPLOY_API_KEY }}
          DOKPLOY_APPLICATION_ID: ${{ secrets.DOKPLOY_FRONTEND_APPLICATION_ID }}
        run: |
          payload=$(cat <<EOF
          {
            "applicationId": "${DOKPLOY_APPLICATION_ID}",
            "title": "Auto-deploy from GitHub (frontend)",
            "description": "Repository: https://github.com/${{ github.repository }}\nCommit: ${{ github.sha }}"
          }
          EOF
          )

          curl -X POST \
            "https://dokploy.my.intezya.ru/api/application.deploy" \
            -H "accept: application/json" \
            -H "Content-Type: application/json" \
            -H "x-api-key: ${DOKPLOY_API_KEY}" \
            -d "${payload}"

  deploy-telegram-bot:
    name: Deploy telegram bot to Dokploy
    needs: telegram-bot
    if: needs.telegram-bot.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to Dokploy (telegram bot)
        env:
          DOKPLOY_API_KEY: ${{ secrets.DOKPLOY_API_KEY }}
          DOKPLOY_APPLICATION_ID: ${{ secrets.DOKPLOY_TELEGRAM_BOT_APPLICATION_ID }}
        run: |
          payload=$(cat <<EOF
          {
            "applicationId": "${DOKPLOY_APPLICATION_ID}",
            "title": "Auto-deploy from GitHub (telegram bot)",
            "description": "Repository: https://github.com/${{ github.repository }}\nCommit: ${{ github.sha }}"
          }
          EOF
          )

          curl -X POST \
            "https://dokploy.my.intezya.ru/api/application.deploy" \
            -H "accept: application/json" \
            -H "Content-Type: application/json" \
            -H "x-api-key: ${DOKPLOY_API_KEY}" \
            -d "${payload}"
